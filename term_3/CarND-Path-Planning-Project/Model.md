The key idea of my current design is to increment my waypoint s in frenet frame and directly translated to world coordinate (x,y) using two splines (s,x) and (s,y) which are built using map's waypoints data segment projected onto a specific "d" value.

More concretely, the model can be broken down into the following step. Firstly, the map's segment are made of 10 waypoints in such a way that the car current location is always in the middle of the segment. As the car moves along the track, the segment moves as well. This is shown in line 245 findNextWayPointsIndexList.  This way, the continuity of each segment spline is guaranteed.

Secondly, a planner class is designed to monitor car's sensors data and update car's behavior state machine. There are only three state defined for behavior for simplicity. They are keep lane, lane change right, and lane change left. This module can be found in updateState function at line 323. The function has some simple cost functions to avoid collision and does not use very precise and full predictions.

Lane keeping is implemented in realize_keep_lane at line 423, this function is effectively similar to an adaptive cruise controller. the controller takes [targetSpeed, timeToTarget] as input, which are then feed into a JMT to generate a smooth velocity curve. it outputs next velocity for the current timestep which then be converted to distance increment shown at line 480. Finally, since it is lane keeping, it use current_d value to build splines[s,x] and [s,y] and then converted back to [x,y]. This can be found at line 487 getSplineForWayPoints.

Lane changing has very similar construct with Lane keeping, which can be found in function realize_change_lane at line 494. The only difference is it use next_d value calculated by JMT at timestep as parameter to pass into getSplineForWayPoints instead of fixed lane's d value. The key is to use the last issued way points [s,d,v] value as initial condition to make sure a smooth lane change.

In the main function, the number of way point generated on each timestep are based on how many the waypoints left in the simulator. So if the simulator consumes only one, there will only be one generated on the next timestep to keep 50 waypoints in total.   

Reflection: I have at least tried three methods so far. I projected map's waypoint[x,y] onto car's local frame instead of frenet coordinate, which woks well on single lane but I found it difficult to combine with speed controller and lane changing which is easier in frenet. I also tried to directly interpolate more map waypoint data on frenet frame and then use getXY() function to calculate next waypoint's (x,y), which also works well. In the end I decided to go with current design, the only downside is s value for the projected waypoint for each d needs to calculated rather than using s value in the provided map data, which results in small speed inaccuracy.
